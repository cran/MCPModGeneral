<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>1 Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<ol>
<li>Introduction</li>
<li>Exploratory Stage

<ul>
<li><code>powMCTGen</code></li>
<li><code>sampleSizeMCTGen</code></li>
</ul></li>
<li>Data Analysis Stage

<ul>
<li>Do things by hand using <code>prepareGen</code> and the <code>DoseFinding</code> package</li>
<li>Do everything all at once using <code>MCPModGen</code></li>
</ul></li>
</ol>

<h1>1 Introduction</h1>

<p><code>MCPModGeneral</code> is an extension of the <code>DoseFinding</code> package, streamlining the analysis of non-normal endpoints. Almost all of the functions in the <code>DoseFinding</code> package rely on the user supplying \(\mu\), the estimated dose-response coefficients, and \(S\), the variance-covariance matrix of \(\mu\). However, \(S\) is difficult to know before-hand, and for functions like <code>powMCT</code>, differ for each alternative model. The <code>MCPModGeneral</code> package does not require the user to supply a matrix for \(S\) and instead calculates the theoretical variance-covariance matrix for the negative binomial, binomial, and Poisson distributions. Alternatively, the emperical covariance matrices can be estimated via simulation.</p>

<p>Users can also use the <code>MCPModGeneral</code> package to fit the full MCPMod procedure on negative binomial, Poisson, and binomial data, as well as basic survival data. The relevant functions for fitting the models are <code>prepareGen</code> and <code>MCPModGen</code>. The full capabilities of these functions will be explored later in the vignette.</p>

<p>As with the <code>DoseFinding</code> package, the <code>MCPModGeneral</code> package still requires the user to create and specify the potential dose-response curves. The <code>DoseFinding</code> package provides the <code>guesst</code> and <code>Mods</code> functions to create these models, but ultimately, the dose-response curves come from prior knowledge or discussion with clinicians. For the entirety of this vignette, it is assumed that the user is able to construct the potential models. Recall that dose-response curves must be constructed on the same scale as the ANOVA output, meaning if negative binomial data is to be analyzed via a GLM with a log-link, the dose-response curve should represent the log of the means at each dose. The <code>MCPModGeneral</code> package allows usage with the most commonly used links. See the <code>family</code> page from the <code>stats</code> package for a list of the common links.</p>

<h1>2 Exploratory Stage</h1>

<p>Before collecting data, it is useful to understand the properties of the potential data set. The two relevant functions in the <code>MCPModGeneral</code> package are <code>powMCTGen</code> and <code>sampSizeMCTGen</code>. <code>powMCTGen</code> will calculate the power of the multiple contrast test for the patient allocation and dose-response curves provided. These are extensions of the <code>powMCT</code> and <code>sampSizeMCT</code> packages from the <code>DoseFinding</code> package. While the <code>DoseFinding</code> functions can handle non-normal data, they require a user-provided covariance matrix. We find this unneccesarily prohibative in common use since the covariance function is unlikely to be known in advance. Furthermore, only a single covariance matrix may be supplied, while the covariance matrix for non-normal data typically depends on the expected value at the doses. The <code>MCPModGeneral</code> functions work by calculating the theoretical covariance matrices from the means of the supplied models and then calling the <code>DoseFinding</code> functions. All theoretical covariance matrices were derived by hand for the most common links.</p>

<h2>2.1 Power Calculation</h2>

<p>The original <code>powMCT</code> function calculates the power for a multiple contrast test under each alternative model. As discussed above, the <code>powMCTGen</code> function works by calculating the theoretical covariance matrix at each of the alternative models and then calling <code>powMCTGen</code>. We added two new capabilities to the <code>powMCTGen</code> function. First, the user can change the doses in the function instead of having to redefine a new <code>Mods</code> object with the new doses. Second, the user can supply theoretical responses. Note that only one power calculation will be provided in this case, since the responses are no longer assumed to come from each of the models. Now, let us create the set of candidate models we will use for the following examples. We include 5 candidate models in our study, shown below.</p>

<pre><code class="r">dose.vec = c(0, 5, 10, 20, 30, 40)
models.full = Mods(doses = dose.vec, linear = NULL,
                   sigEmax = rbind(c(9, 4), c(20, 3)), 
                   emax = 1.25, quadratic = -0.044/2.667,
                   placEff = 0, maxEff = 2)
plot(models.full)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAADYCAMAAADxhokmAAAA2FBMVEUAAAAAAC4AADoAAFIAAGYAM1IAM3MAOpAAXFIAXHMAXJEAZrYAgP86AAA6AC46AFI6AGY6M1I6M3M6OpA6gHM6gK86kNtmAABmAC5mADpmAFJmAGZmMwBmMy5mOjpmOpBmXFJmo69mo8xmtv+QMwCQMy6QOgCQOjqQOmaQXACQgFKQkLaQo3OQxcyQ2/+2XAC2ZgC2gC62xXO25ZG25cy2///T09PbgC7bkDrbtmbb5a/b5czb/7bb////o1L/tmb/xXP/25D/5ZH/5a//5cz//7b//9v///9Qm8QFAAAACXBIWXMAAAsSAAALEgHS3X78AAANyUlEQVR4nO2di3/bthHH6TWtu5huumSWlzRbN9tN93KsbbajLrMVP/X//0fDg6QA4gDieSSr+33cKjoRR+grCDwQwKnakFBUjV2BXRGBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRhKBRtLkQC+r33zUDE8/XPWszx+qav9Gty2r6tQovFoA/kbS1ECv92/Yn2qoXlz1rOsDxu9UszET+0B6hdfVwvQ3lqYGmjVC0YRbPf/j+a9XhpUdd9q3sSe66e7NLwug5EiaHOjTDSerSIDuW1kL7tmWrPlqJt7CF4C/kTQ50EYLhFr08gA4crXQTKuKaUEt2iKzT+Wgdevzh9P+kaztMtD9wmvqo+0yogTxze9HGKytGrYDo/Caoo7dE4FGEoFGEoFGEoFGUgpooGwOk1+BUn6jTQMi0LlMAyLQuUwDItC5TAMi0LlMAyLQuUwDigRdkZgwQD8W0czcEmgktwQaye3IoL+8umR/cVW3emz/dcj7xr1z59nzu+Wvn5huxwfteNWpwaY36Pu2+sobtLfb+z+cP375zvgYJgCa/73+m2gF98fircs28eV37wEODiK3FS/NOTA/X//xvCXy8NPfq+qIvXrUur44evz08vFi758+LTrQ7e1L9tqF0aQnAvrw6PH2m88NANEmuNH8ArqI3L+75KU5B+bndm9L5IxZD8Urjev7d/95d/no13VEuBXvYJqgX1229b1vqvpusO82iMh3J97wJWtv57Iz/eYz+yd/2h4gyPFm6Ak63O3D2ZHpdlKgj5urzAX/toaC5t/fPfldeP1ZEOm+4wqRC9kRfNfSK+D2/tjkPDHQTWs+PvGJRiC3rP9Rmp5JpHH9ePHnl96gQ93CXd6kQItOULwn3jZCQfNOvind60y3RFrXr//707kn6FC3lkvLtECzvoP3HJ+q6uv3J8Et+kIND37bdqbVifodF67/cnYi+Pm16EC3/5KvTg10gtxuowP0Um4xQJOqfHfvmgXfG2BdlSh2bRaJNdV1HejW7sQ0VUl1s54pG2i54HsDrTzMDLpmpq7qfj5Mqq0T05QbtObWU0MHrzhode2r8s25bp5tQh+v+3ZGraqr5qmX25o91vxxSFVtPavv47X+XHfr24EMHMYbNbQ6PG+LZhUPbdEtR9WE0KLlOfO36KXgDKwOzwlaVD2kj5bv1qBauo9WPtfMfbRc8L2x9tF5pNLxcdu8XYCqVWm1FWeqgfNlAy0XfD/9eGOJOnJIr/6w2wC8IW5dZ4Qph7qNjaPjivXVr/+Q2yjMqaAtmBFBp3d6fdOAW+0NB5wqpY/uLtQ2t54aD7TeTHxAQyW8ThUPuumeXW495T64jTVYb6130kmgZZgBHeV0C5bwMsWCbirpdusp58FiezDT88/9jU0poFlkZjaSYdDwR+NligPdVbI4aLk9mOnpT4fVQVugGRVysRPKh6BHcXWBX3e5rYfdX1vswi2DE1RbHqoPuM03MmxAr19cybG4ZzGnZFgaXJu4eGPQrfV0HufL2EcrA2++OTLyHKqUYWBQbVI4R9TWK47MD1psAM7RooeGcxa31kjWU8G19TtbJOjV/s1KZBdRxEHLkWG1MItlv7pY3IqrZ9ipdFPgxdD3shsH+untR/Z3971fJoAI0EqrDAZtDWX9TAGgoXFgZtA/XLE2XQ60OQwEjrKCBr7MRUCDX57M4d2KjUnWva7DXSxxGAgUtLgFu+hCoIHPtPyARRkZRs8Z2oeBgMkGGihQCLT1xobVrae8RoYJ96ProFtutqjD20GQW+BEQfFNJOi1GOa8MBJHbcA5Q98xFh8E1t4jR9htHTak83UL1TbMbdTI8OkY6J5b0PCcoYdE+0htI6kN2re2ocF6dNRhvgq0aKXYYKdnGwaG9dE1WCB/Hy0rGuzWU9uDlwvz1XZkGLWuow6u+aigB+6JWt16Suk6jD5aHRkGRx3Dw0DANCLoiOpOYYbFZxgImCC3NVwgM+iuvrMCXXsNAwHTaKCj2kX0yNDsOjyKmUq41Qa4TQ45YLe9k0SdJfqmEk/4eaC+2HXN8JyhKWOZVqBGAo2xikEN7+Tf9rUu2LDMGRoKGwa6aqP5TNYAkdg6x4FmMNmfdveuC5995wzFMNBjTGWdvTPd+rjrHq+dI0PbWeUEZozbuDlDxnit39/vBoSWOUMjDoNWHiZeDK3BbbaLYa89jxF1aANCYM6wPwx0rDXxNBlu7cFtLtDJqxg85Tq466Mtc4Zq0Bw+roJMyKChK3d50M8fqv3/vdWueiLqGJwzrOPCfcikg65dbjOABm/EFAf9/GFx98Y7qbV6DrkGPou0qifHMLBb5QSJFY8O7xho3zTtyjlcC2JC1QOd6wO0BKNht3B93Q4dLFv0KrRFuxfEhEoHne0D1InI6maoeHwf3W4rbKWMDIG7d9AwMEMf3fms8/bRrbdacZ1W3QJRB3Q/OvVSApmqbiOV7jsD6DbG15rHKKDNOcMujgb3GfKtdnXczj3rjj/pVuzjy7AhUHVb1cqOuSrMvcttxJzhW+PHHbqRIThnmDwMBEwBbmNbdPS9ctitt1xzhmCLboqRqthN96tF/zVXHx2XeGEwMUMhtyFECsl5418ZGfajjkJECrlFgumSq492FStEpJDbAuBC5eqjXcUKESnktgC4ULn6aFexQkT8D304U3McuTOQTQo0uK7DXiyBpkMpoF1ui+HzV+xyAxcDmY7Ulj40EHSTxqvJOdakveUZRd+fiEynwsLP+O9tSrJdAS2BOvJ8BoDmqSo/7bWgG0ciW111wtPRtUlPxd9Dm5NtN0A36UjteT5DQPNibbq/V22KU5F/8azLoieTnjq66V8raJmO1J4+NAS0kjxUYNymOL1oQLeWJtPoLoGW/YM9fWgIaL1FN46UFr1NejqPFt3EHHmiDpmO1J4+NAS06PD3zkUOS9mU+dei6aPbK6RIetr00WDKzIIAfVUo6tg7f7SnDw0CzZx9Kz38XvTyPNxgzbnLdCotD2e7GHXEC3YLJCMPdJuXWZScyw0cxealQvBClLLcIPa2uTU/XYhbP7/mHXpHwtWiSlluEEnVnnExDbR9bkYF7Ui4WlTByw2UL2S7oHLjeOSzc7WcDHQrMDep9mg601/vdyBGwlUEOZcbDBRzN9/+m9++kLVFb30rfrfngyb3bAlXiyo26uD/g7+8OtmgHKIhoGszkaXutz1g03+T1oSrRZUC2hC0pCZoNZB/bdrFRu6DmsVO+sXQmnC1qGJHhqapYYy0yAr4SOGj+qAdCVeLalsHsXNW3yzkU2yjLmNLXMzmD7ptq0OHbYwWPZZ6c4Yx4V2x9dHWAttPdsgv1EePIzW824gMVv7FOtDb5bUooMvuji+kXnjn2XPooJVvMQLotilHg7YmXC2q9PBOuyyVB528aduecLWogkG3o8JuC55IeOS5ETB8n2HvsXbuO/TZEAgmXEVQyshQKNtqf90trCx7ia0JV4sq5WIolJPz4F7iLG6tCVeLKiW848rK2Q06V9IEa8LVokoN7/LvYbG9mm2LqzXhalEl3r3rN7JyoL0zhgKmacXR4cXQQIM3Ngh0gsl69zVHtt1xNQ/QWbLttrImXC2qpg6igw6/TZo35rDf5s5599WecLWo2jqsfC/BysiQvf2wEeHgoyU3aV2HJQ31GhmON8PCdwv5xjuYLTr9JGAcPe6c4TKk6yiyoRO8JwoUSIujN2O2aD7J4ztSkkTS8voAJgi0pUAy6PH66JDhKBrojMmrWlkTrhZVStSBANp+k3+n4ujCoJ3pHnYJdPagoze5ni21DYGG3TaqsyXF0tzaE64W1aRBl8ip5Ei4WlRJc4axPyfhN2fYDAgD3PvMGYIJVxE03Yth5pxKrRwJV4sqBTTwvc4HujZfjfargbYnXC2qqYIe/HGtWNCOhKtFNVHQw7mGo+Noe8LVosoMOlFjTK4jaZqgM3sm0KDbzKufNrMH7bdCObiP9pzxTuujtX+gKB500I9Zepoqy5R3kahjpH2G3gValctNGuvWK4moIz1lUaW06FnlJm3lSLhaVLGg5yWl5jNr0bayOUx+BWJPNZs+2l12+qAdCVeLavdAjyQCjSQCjSQCjaTJVOTXLgKNJAKNJAKNJAKNJAKNJAKNpHjQxq0CcS9MtTZJE7UDl2Iddq8s/x0H3DsP+IoGbdz8ErudNKtMmtg3sc+jV3ZdLbDvpeErGnT/dq7c7WTc5F2d9k3siW66e/PLAvvuML7iQRsTFAJ0z8pacM+0ZM1XM/EWvsCe78BXthbdgNatPGmi2cgXmkn8RteCWrRNZqfKQWtWmTRR76P5grdFv+ya+miHjDBBfPVVq0yaaEQdB0bZNUUdpFwi0Egi0Egi0Egi0Egi0Egi0Egi0Egi0Egi0Egi0Egi0EiaEei7Q36TCm+va17NCfT3V/wHY2ZKem6gN3dvbvjP8/DcT2uZAqp5NnHNDvTT24/8t3nW++InAfkP9LBnvr/TM6JmB/r554+cMOP9JH9OlD/MYBZsdqAZV/4PnqiHXR35dhT+M1/Tn52ZHeimz2iac/NsBpobaBF1LLvJXP6ffDZ27YY0J9BdHN3EGcsu6ph+zzEn0PMWgUYSgUYSgUYSgUYSgUYSgUYSgUYSgUYSgUYSgUYSgUbS/wFhOAGE6IYkjQAAAABJRU5ErkJggg==" alt="plot of chunk powMCTGen"/></p>

<p>The above plot shows the potential dose-response curves on the link-scale (e.g. on the log-scale for negative binomial data). The doses considered are \((0,5,10,20,30,40)\). Now consider a trial where 30 patients receive each dose. We wish to calculate the probability of accepting at least one alternative model given the true underlying dose-response curve. We first assume that the endpoints are negative binomial counts and the dispersion parameter is 0.1. The following chunks of code demonstrate three ways to calculate these powers. The &ldquo;verbose&rdquo; parameter specifies whether the assumed patient allocation should be printed. This is useful to ensure that the patient allocation is what was intended.</p>

<p>We demonstrate the use of <code>powMCTGen</code> below.</p>

<h3>Using the &ldquo;arm&rdquo; Ntype</h3>

<pre><code class="r">## Look at the power for each possible DR-curve
powMCTGen(30, &quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.1,
          Ntype = &quot;arm&quot;, alpha = 0.05, altModels = models.full, verbose = T)
#&gt; the patient allocation is given by:
#&gt; c(0, 5, 10, 20, 30, 40)c(30, 30, 30, 30, 30, 30)
#&gt;    linear  sigEmax1  sigEmax2      emax quadratic 
#&gt; 0.8634713 0.9520507 0.9352006 0.8474744 0.8875665
</code></pre>

<h3>Using the &ldquo;total&rdquo; Ntype</h3>

<pre><code class="r">powMCTGen(180, &quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.1,
          Ntype = &quot;total&quot;, alpha = 0.05, altModels = models.full, verbose = T)
</code></pre>

<h3>Using the &ldquo;actual&rdquo; Ntype</h3>

<pre><code class="r">powMCTGen(c(30,30,30,30,30,30), &quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.1,
          Ntype = &quot;actual&quot;, alpha = 0.05, altModels = models.full, verbose = T)
</code></pre>

<p>Now let&#39;s assume our dose-response models define the probability of occurance on the probit scale. We need only to change the <code>family</code> and <code>link</code> arguments, and remove the <code>modelPar</code> argument. Note that the <code>modelPar</code> is simply ignored for <code>family = &quot;binomial&quot;</code>.</p>

<pre><code class="r">powMCTGen(30, &quot;binomial&quot;, &quot;probit&quot;,
          Ntype = &quot;arm&quot;, alpha = 0.05, altModels = models.full)
</code></pre>

<p>By default, the doses are assumed to be the same doses used to construct the alternative models. However, the user now can also supply their own doses to see what effect the choice of doses has on the power. Consider the next example, where the doses are either very small or very large, which no doses in the middle of the dose-range. We see that the power decreases for some models, especially &ldquo;sigEmax2&rdquo;. This is because certain choices of doses do a better job of defining the underlying shape of the curves.</p>

<pre><code class="r">powMCTGen(30, &quot;binomial&quot;, &quot;probit&quot;,
          Ntype = &quot;arm&quot;, alpha = 0.05, doses = c(0, 1, 2, 36, 38, 40),
          altModels = models.full, verbose = TRUE)
#&gt; the patient allocation is given by:
#&gt; c(0, 1, 2, 36, 38, 40)c(30, 30, 30, 30, 30, 30)
#&gt;    linear  sigEmax1  sigEmax2      emax quadratic 
#&gt; 0.9999939 0.9999952 0.9999961 0.9999172 0.9999866
</code></pre>

<p>Another nice extension to the <code>DoseFinding</code> package is the power function can now handle theoretical response values. Instead of supplying a dose-response curve, the user can instead supply theoretical mean values (on the link scale) at respective doses. These doses do not have to be the same as the doses used to construct the alternative models.</p>

<pre><code class="r">## Now consider power at some theoretical DR-values
powMCTGen(30, &quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.1,
          theoResp = c(0, 0.2, 1.8), doses = c(0, 20, 40),
          alpha = 0.05, altModels = models.full)
#&gt; [1] 0.643238
</code></pre>

<p>This can also be used to test the type-1 error, if needed, although this should always be \(\alpha\).</p>

<pre><code class="r">## Can also check type-1 error
powMCTGen(30, &quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.01, theoResp = rep(0, 5),
          doses = c(0, 50, 10, 20, 30),
          alpha = 0.05, altModels = models.full)
#&gt; [1] 0.0501295
</code></pre>

<h2>2.2 Sample Size Calculations</h2>

<p>One could keep adjusting the patient allocation in <code>powMCTGen</code> in order to reach some target power, but <code>sampSizeMCTGen</code> offers an automated process. In addition to the family, link, parameters, and models, the user also needs to supply a &ldquo;guess&rdquo; of the largest sample size needed to reach a certain power, and the desired power. The following line of code calcualted the optimal sample size for binomial data with more patients allocated in the ratios \(3:1:2:2:2:2\) for the respective doses, in order to reach a minimum power of \(0.8\).</p>

<pre><code class="r">sampSizeMCTGen(&quot;binomial&quot;, &quot;logit&quot;, upperN = 50, Ntype = &quot;arm&quot;,
               altModels = models.full, alpha = 0.05, alRatio = c(3/2, 1/2, 1, 1, 1, 1),
               sumFct = &quot;min&quot;, power = 0.8)
#&gt; Sample size calculation
#&gt; 
#&gt; alRatio: 3 1 2 2 2 2 
#&gt; Total sample size: 84 
#&gt; Sample size per arm: 21 7 14 14 14 14 
#&gt; targFunc: 0.8131
</code></pre>

<p>If <code>verbose = TRUE</code>, current iteration, N, and power is printed at each step. Let&#39;s pay more attention to the <code>sumFct</code> argument. Recall that <code>powMCTGen</code> returns a vector of powers, one for each alternative model. <code>sumFct</code> converts this vector into a single value. The default is to consider the minimum of the powers, so that in the worst case (the true model is the model which has the lowest power), the power is still above the target. Like <code>sampSizeMCT</code>, default functions are &ldquo;min&rdquo;, &ldquo;mean&rdquo;, and &ldquo;max&rdquo;. However, <code>sumFct</code> can also handle user-supplied functions, as long as the function accepts a patient allocation argument of the <code>Ntype</code> specified, and returns a numeric value.</p>

<pre><code class="r">sampSizeMCTGen(&quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.1, upperN = 50, Ntype = &quot;arm&quot;,
               altModels = models.full, alpha = 0.05,
               sumFct = &quot;max&quot;, power = 0.8, verbose = T)
#&gt; Iter: 1, N = 31, current value = 0.957
#&gt; Iter: 2, N = 22, current value = 0.8812
#&gt; Iter: 3, N = 17, current value = 0.7954
#&gt; Iter: 4, N = 20, current value = 0.8514
#&gt; Iter: 5, N = 18, current value = 0.8159
#&gt; Sample size calculation
#&gt; 
#&gt; alRatio: 1 1 1 1 1 1 
#&gt; Total sample size: 108 
#&gt; Sample size per arm: 18 18 18 18 18 18 
#&gt; targFunc: 0.8159
</code></pre>

<p>Just like <code>powMCTGen</code>, <code>sampSizeMCTGen</code> can also handle theoretical responses at supplied doses.</p>

<pre><code class="r">sampSizeMCTGen(&quot;negative binomial&quot;, &quot;log&quot;, modelPar = 0.1, upperN = 100, Ntype = &quot;total&quot;,
               alRatio = c(3/2, 1/2, 1),
               theoResp = c(0, 0.2, 1.8), doses = c(0, 20, 40),
               altModels = models.full, alpha = 0.05)
#&gt; Sample size calculation
#&gt; 
#&gt; alRatio: 3 1 2 
#&gt; Total sample size: 114 
#&gt; Sample size per arm: 57 19 38 
#&gt; targFunc: 0.8015
</code></pre>

<h1>3 Data Analysis Stage</h1>

<p>In this section, we will explore the two methods for analyzing non-normal data using the <code>MCPModGeneral</code> package. The first method uses the <code>prepareGen</code> function to retrieve the \(\hat{\mu}\) vector and \(\hat{S}\) matrix, and then passes these objects into <code>DoseFinding</code> functions. The second method combines the two steps into one via the <code>MCPModGen</code> function.</p>

<h2>3.1 Binomial Data</h2>

<p>First, consider the data. This data set is provided in the <code>DoseFinding</code> package, and the primary endpoint was the binary value &ldquo;pain freedom at 2 hours postdose.&rdquo; We also construct three candidate models for demonstration. These models were not based off any prior knowledge, and serve only as demonstration of the approach.</p>

<pre><code class="r">data(migraine)
migraine$pfrat = migraine$painfree / migraine$ntrt
migraine
#&gt;    dose painfree ntrt      pfrat
#&gt; 1   0.0       13  133 0.09774436
#&gt; 2   2.5        4   32 0.12500000
#&gt; 3   5.0        5   44 0.11363636
#&gt; 4  10.0       16   63 0.25396825
#&gt; 5  20.0       12   63 0.19047619
#&gt; 6  50.0       14   65 0.21538462
#&gt; 7 100.0       14   59 0.23728814
#&gt; 8 200.0       21   58 0.36206897

models = Mods(linear = NULL, emax = 10, quadratic = c(-0.004), doses = migraine$dose)
plot(models)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-11"/></p>

<p>We can prepare the data manually using the <code>prepareGen</code> function and then forward the output to the <code>MCPMod</code> function from the <code>DoseFinding</code> package. This two step process is shown below.</p>

<pre><code class="r">mu.S = prepareGen(family = &quot;binomial&quot;, link = &quot;logit&quot;, w = &quot;ntrt&quot;, dose = &quot;dose&quot;,
                  resp = &quot;pfrat&quot;, data = migraine)
mcp.hand = MCPMod(dose = mu.S$data$dose, resp = mu.S$data$resp, models = models,
                  S = mu.S$S, Delta = 0.2, type = &quot;general&quot;)
plot(mcp.hand)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-12"/></p>

<pre><code class="r">mcp.hand
#&gt; MCPMod
#&gt; 
#&gt; Multiple Contrast Test:
#&gt;           t-Stat   adj-p
#&gt; emax       4.061 &lt; 0.001
#&gt; linear     3.703 &lt; 0.001
#&gt; quadratic  3.079 0.00226
#&gt; 
#&gt; Estimated Dose Response Models:
#&gt; linear model
#&gt;     e0  delta 
#&gt; -1.710  0.006 
#&gt; 
#&gt; emax model
#&gt;     e0   eMax   ed50 
#&gt; -2.219  1.387  8.473 
#&gt; 
#&gt; quadratic model
#&gt;     e0     b1     b2 
#&gt; -1.776  0.010  0.000 
#&gt; 
#&gt; Selected model (AIC): emax
#&gt; 
#&gt; Estimated TD, Delta=0.2
#&gt;    linear      emax quadratic 
#&gt;   33.8758    1.4274   20.9810
</code></pre>

<p>Alternatively, we can perform the same calculations, but in one step via the <code>MCPModGen</code> function.</p>

<pre><code class="r">mcp.gen = MCPModGen(&quot;binomial&quot;, &quot;logit&quot;, returnS = F, w = &quot;ntrt&quot;, dose = &quot;dose&quot;,
            resp = &quot;pfrat&quot;, data = migraine, models = models, Delta = 0.2)
mcp.gen
#&gt; MCPMod
#&gt; 
#&gt; Multiple Contrast Test:
#&gt;           t-Stat   adj-p
#&gt; emax       4.061 &lt; 0.001
#&gt; linear     3.703 &lt; 0.001
#&gt; quadratic  3.079 0.00225
#&gt; 
#&gt; Estimated Dose Response Models:
#&gt; linear model
#&gt;     e0  delta 
#&gt; -1.710  0.006 
#&gt; 
#&gt; emax model
#&gt;     e0   eMax   ed50 
#&gt; -2.219  1.387  8.473 
#&gt; 
#&gt; quadratic model
#&gt;     e0     b1     b2 
#&gt; -1.776  0.010  0.000 
#&gt; 
#&gt; Selected model (AIC): emax
#&gt; 
#&gt; Estimated TD, Delta=0.2
#&gt;    linear      emax quadratic 
#&gt;   33.8758    1.4274   20.9810
</code></pre>

<p>Notice that the results for the two methods are almost identical. Slightly different values are given (e.g. the adj-p values), but this is due to the computation method.</p>

<h2>3.2 Negative Binomial Data</h2>

<p>The <code>DoseFinding</code> package does not have any negative binomial data, so we will simulate data according to the same model curves we used for the binomial data. Five random observations are shown from the data set to demonstrate the structure of the data. To demonstrate the affect that additional covariates has on the model, we will use extremely large sample sizes for each arm (300 patients per arm) and a very large gender effect.</p>

<pre><code class="r">## Simulate some negative binomial data according to one of the models
set.seed(188)
mean.vec = getResp(models)[,2]
dose.dat = c()
resp.dat = c()
gender.dat = c()
for(i in 1:length(migraine$dose)){
  gender.tmp = rbinom(300, 1, prob = 0.3)
  gender.dat = c(gender.dat, gender.tmp)
  dose.dat = c(dose.dat, rep(migraine$dose[i], 300))
  resp.dat = c(resp.dat, rnbinom(300, mu = exp(mean.vec[i] + 5*gender.tmp), size = 1))
}
nb.dat = data.frame(dose = dose.dat, resp = resp.dat, gender = gender.dat)
nb.dat[sample(1:nrow(nb.dat), 5),]
#&gt;       dose resp gender
#&gt; 876    5.0   24      1
#&gt; 398    2.5    1      0
#&gt; 2281 200.0    3      0
#&gt; 1780  50.0    9      0
#&gt; 2126 200.0  453      1
</code></pre>

<p>Now we will perform the MCP-Mod procedure on the negative binomial data, both using the default approach, and also on the placebo adjusted data. Note that we also show the different ways to supply the <code>dose</code> and <code>resp</code> arguments, which differ slightly from the <code>DoseFinding</code> package which does not use character vectors. We show only the results for two of the objects (one default, one placebo adjusted). Note that if <code>returnS</code> is TRUE, the returned object will have three arguments. One with the MCPMod object, one with \(\hat{\mu}\) and the doses, and one with \(\hat{S}\).</p>

<pre><code class="r">mcp.nb1 = MCPModGen(&quot;negative binomial&quot;, link = &quot;log&quot;, returnS = T,
          dose = &quot;dose&quot;, resp = &quot;resp&quot;, data = nb.dat, models = models, Delta = 0.6)

mcp.nb2 = MCPModGen(&quot;negative binomial&quot;, link = &quot;log&quot;, returnS = T,
          dose = dose.dat, resp = resp.dat, models = models, Delta = 0.6)

mcp.nb3 = MCPModGen(&quot;negative binomial&quot;, link = &quot;log&quot;, returnS = T, placAdj = T,
          dose = &quot;dose&quot;, resp = &quot;resp&quot;, data = nb.dat, models = models, Delta = 0.6)

mcp.nb4 = MCPModGen(&quot;negative binomial&quot;, link = &quot;log&quot;, returnS = T, placAdj = T,
          dose = dose.dat, resp = resp.dat, models = models, Delta = 0.6)

names(mcp.nb1)
#&gt; [1] &quot;MCPMod&quot; &quot;data&quot;   &quot;S&quot;
mcp.nb1$data
#&gt;    dose     resp
#&gt; 1   0.0 3.975311
#&gt; 2   2.5 4.037421
#&gt; 3   5.0 3.969348
#&gt; 4  10.0 4.156954
#&gt; 5  20.0 4.558707
#&gt; 6  50.0 4.435765
#&gt; 7 100.0 4.774885
#&gt; 8 200.0 4.908036


mcp.nb1$MCPMod$doseEst
#&gt;    linear      emax quadratic 
#&gt; 130.84452  41.37549  67.10633 
#&gt; attr(,&quot;addPar&quot;)
#&gt; [1] 0.6
mcp.nb4$MCPMod$doseEst
#&gt;    linear      emax quadratic 
#&gt; 130.84452  41.37549  67.10633 
#&gt; attr(,&quot;addPar&quot;)
#&gt; [1] 0.6

plot(mcp.nb1$MCPMod)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-15"/></p>

<pre><code class="r">plot(mcp.nb4$MCPMod)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAADYCAMAAADxhokmAAAA1VBMVEUAAAAAAC4AADoAAFIAAGYAM1IAM3MAOmYAOpAAXFIAXHMAXJEAZrY6AAA6AC46AFI6AGY6M1I6M3M6OpA6gHM6gK86kNtmAABmAC5mADpmAFJmAGZmMwBmOgBmOjpmOpBmXFJmZmZmo69mo8xmtv+QMwCQMy6QOgCQOjqQOmaQXACQgFKQkLaQxcyQ2/+2XAC2ZgC2xXO25ZG25cy2///T09PbgC7bkDrbtmbb5a/b5czb/7bb////o1L/tmb/xXP/25D/5ZH/5a//5cz//7b//9v///9k/b7SAAAACXBIWXMAAAsSAAALEgHS3X78AAAMgklEQVR4nO2dDX/bthGH0bVrvcXuunSxl65rt1mJu62OvS2OtiyRHdvS9/9IJcA3vByBw9uRTO5+TiQdgT9Pj6AjBBCkOLCRmJg7gE/FGDSRMWgiY9BExqCJjEETGYMmMgZNZAyayBg0kTFoImPQRMagiYxBExmDJjIGTWQMmsgYNJExaCJj0ETGoImMQRMZgyYyBk1kCwV9LX71ynJIj+5+/NPrvtzg7nxa0f2FEEfv7HIz2DJB747eNX+aY//TK8u9E1+87hyDW/nMorvjhu/GKjeHLRP09rRtnIM9/nAijnX3/uf93193jt7d+pyih+3GLDeLLRT05iCZjbZrmmrDS3cr0MoxuuWDU7Rp1Ha5GWyhoKG2tzs13G6LPoxstaLXxwen3Ay2TNBONt2dymZuuFXrtXKv8hlF9xebQY9ztGtQr+PUdKvWa/UmOp9WtHkhX3Kv45MxBk1kDJrIGDSRMWgiywEN1QX1sAVFxPa5tPEFo4tE1WXQE8agI30MmkibQRNpM2gibWLQgs21KqAf6tlqtRk0kTaDJtKmB337u/80f8kBp1Ysrn3/4lx7FXpX84COekNWwBl1y2o7oP3as4CWf0//IUQT6Ycz8XkT4u2JfHX7++8/D3wKIRit3v3Lfwrx7H3zr5e+evbw5kmgLqzdKP725aUEqf6d9GH/+vtzFa/yyN3+q9ncPH52CWrPBvrk2cP7L992AD788VL5T84DLIKgW737F08aJE+kZif94bt/fxf6JoHa9y8axc960J2a3M17cS7j7UNXf7KVy3cFaM8Gegz8Q0ugeUBklQDoTu/+5eWD/CdfttIPb2TrTtCWdRuZvkW3HulsoPbxtqF70/TsoM+avrz8sl2J5itfAHSrZ4BW0g+3X4Nf6aD27dO3UmoAPQZ61YHuPSohQq1Zac8NumvNZ+fI3kgIdKunge6kH67+EkrRmBbdqWktegx90S1aJbsv36pXX1/mg+70NNC99NP/vQw1aVj7SuVo+d140zZl+d3ocnR/hFShdzkafhOzg+4O02+EOorng2719NShpP82eZQKajeKv2ll/qBSvQy0ac5DvK3n/sXieh15Not2d0zN0q4Cms21KqDlfzfABsiHLnijhRRXh057umA90JXs49ReEuju27c67U58NaD7PLc27V58NTnahFEyR48Hqyo5mkH3oqKg9kcA2syjBUDrfa5i2mPP1nAdVgW6YPfO6dcW0bY+uuF55e5d6dRRqq8L/ngooN3K3riudfWjhfMkTcb7Ey1De0JXa+L+6ol7TavmUywBOvQ7OF3bI9xvWgdo7Y2kagcpZ2mHt64iR2upLi2PGhmj9FiHgXmGsY5yoIUOIAGG1ZgLg0aKrwB0/04SYTjf67KgBbJgBuhhpamz5DQKNJg8DdCGLwqGpysH+WK1Dy6hCqDH62A4i6hjQMOD4vrPZNMXAyOobfnitR31CqCHqwHcfftOXmBk3L0QN43JPSAeQ+WF/RqvHR9LbNwitvwUUC/o4foWO2FdFSAmtQemeZxteG3MFFKqdjDuSG1Ui94eH+6+MS50EXUMjeOM1m4zaBSLgnHHaqNytHtFkWK9DqCLisujQsTk27ReBwinWq/j8cd38lJbG7daAdBQFxUFwxw4w+8vpo6IezOL7kenDmWOH1A90CLyzSwZNPhbAAFDAD7M/mJAi8w348qlWBnQ8G+BIAzc0EOa9mBiQaBzbeKgHtKO6wvEaefsZLGgp95LaEg5Z9940KW15wOd9BsqkzO+j15ce7YcPT3Q5M2jESN10dpacNM6qzsYQjvGgMZoM2hNIA1GzEhdrLYWnEdnZaDhHwNBGIFx7bAP96vTp7Mu0BN91BCM0ARC2LdO0MkWmFNOq4bbc6Ey8fXmAJ26CKFEn7JIkZSKM4BOPcmlyI+kIkVSKoaHSaVthTg2tmTk6OA48sR24TuAYn3hHB0aR6mRo8fJWXVHAqdaIujpgn7QsVAjtEdfcMCqBuhxKuuvY4vWJmcb+W5SMjB5eaO9FsFyQq8z7GpqHzeoiVO/tlZWpGgPcrmTs+oy+VMt2lQPNQLEgL3e6gZx94zZoA5a2/CFdOq26E17lX2rWgJozMwIDNpfB+sLgg7q5IOWE4PmIc/I0UCLPgDx+g1VUC9jrj3JN0h7YnOWtmfr/kI22a1Bup+clb2OU7ja4RAxK48raBQy1p7kG6Q9tTlLe3prmySw9ylJigj5gQClSnGu86MiUls1ZrNFB6rFdu+CB5rJLliwS4j1+YdgbVRVcvTjWdc9+QLTplNAhw80UzB8w5YlQWN0lj96J8IFGTRcLQq0/b1cHmgXRR3Q26N3W/vML3+1GNA5Z+Uj+t7J2uN2gFOdHP38VfNnnTQaroa0mKFkp2ixPodXKnsv+O5d06ZzQU+uekSpwtrD68jTaDHa44aK2tbWbfPrZBeVOgA3/Csx7zzj/nXsieEY7cFfURuz1V/NzVZToAEFfB71gy6To/Hay+h1wPF6Ti2AfBYMPXN8FKD3F+Lo/8+RN1ac6nWAnPNgjILgt6UcaJxONuj9xalcfIW8VWhE9y56CsqEIZztWJ2wthZk9HiC68P3OhrQ5qCSto5zC4zeoWKbOs94UaAjYizUord6i9bWce48w6R+/fiDgPC8yrWp3lJFbWerGvg3Mse4GOvu2//2oOMWdMYsiOwfTe3QfGSOdtl9FJgzbHDv0lp0SlMRky/yDZYrsxN8jra3jXOG8pOamjM0zfQljSMbeVS427E6Qe0hShGhk5+jf3J6dvpae6hFB2NLG3UTzvNwnRRtM0y6XseZO+w/zBmmgS6w6JICtG/oNEZ8tvHoEosuGbR3l20RATihgraPQUdVSx8MExPPSxhyxKuUdv5uEKDThM2apTl/hKAzwqcFXW4Xs+TonNyq5UwBbc/xufk4tme0rINhFqARhh0cg7Z3uR7Q0V3QJYEutoyYQXtBux275YKO7+svpx9dcDa5eKfDUSy5B3LQaYqQQHXQRXdADDo/duE8KWfrBA1lK1AvMY9m5nqvtvYqTqdKju4nZ+UsF+4isHCCZtD+rfELOkXkNflA36cH2rhSZr8qy1zQqZ7JPbWTnO4CSfWYtuhS7QZZJ1ZbLeYUpbSLLeg8tI3arnZjnUkVf6k40Ne3Ojfsci3aZbKQFn1tLSLqqlmgvXtCWy9T4gxPr3Zh8QI5en9hn80LgS4VNxnoStoJW/vJ2Wv4dIPD4VCBswGjlKatXUOcqB/tuQxHah7N1PFpj89jdeYeVDLv8AHFgfYRgU4cyp0ZtPcUjjQYQGQM2n8KxyJBpw7Bzgo64sIoCB+DnqxW9vgtjIeyRjgyGLUVV61Ox59BD9UKX7TE0C6xwtKnvSbQ3a+rnOs9gb7+Q8yde6yjPUOObuNFjPsw6OBWbzVwWJBBT1hmjs68Og7om87Rpbp3Odoz9aNRDSMNRrbOtHZOH70K6MAdOqt2wapI03Qdo7eG7tC52i7Y0rp34/I3bfJQmzPsnzTeEgsi+0fRzT+a85Er0M6fM9QnD7VqtQ+GmSdL1tGukaPBFq1VY9CGr16OvkF2RxN7BtX60Vna9XodckFn3n3Bk4cy83TqaFP3o9lcqwF6si6ohy0oIrbPpY0vGF0kqi6DnjAGHelj0ETaDJpIm0ETac8Bmi3CGDSRMWgiY9BExqCJjEETGYMmsnTQztDptZAew62mC1rP4O98WtluvahVrpohAofizgw8GbQzGdBeCtJw7+T1ClvPOIkgfWbZdr2oVa6aIQKH4s4NPBm0M731+MOJODbc+5/lTGPr6f2tzy273Zjl6lk4cCju7MDTQdsTtrvmA2/2arhVwMoz+uWDU7ZpG3a5WoYJHIo7M/ByLVrt9tR0Ay1jDFErq+61OleLBgKH4s4MvFyOlpeJ3W5Mt2oEVgpTPqNsu150thwNBA7FnRl42V7HqeVWjcA6KHc+rWy3XnTOXocVOBR3ZuDcjyYyBk1kDJrIGDSRMWgiY9BExqCJjEETGYMmMgZNZAyayBg0ka0UtHuBuKUbgyayNYJ+PBNf/XkjH+Qt1HbtndS6V4u1NYK+Pj3IO8XLhyN1l9ztsXJuj8N1Z7MVgpZom9QhHx6fv3ps77AtHyrPgeXZCkHffSNnOjbyQc7+352oRXrydoy152ZybIWgzRYtPV0GWbStELSZo+WMqPzXvpo7tGlbI+j9hd7ruB56HUvOHKsEvUpj0ETGoImMQRMZgyYyBk1kDJrIGDSRMWgiY9BExqCJjEET2S+D+89m39lAlAAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-15"/></p>

<h2>Additional Covariates</h2>

<p>The <code>MCPModGeneral</code> function can also incorporate additional covariates. Consider the same constructed negative binomial data from above. Notice how we removed the effect of <code>gender</code> on the results. We will now easily consider the <code>gender</code> of the patients using the <code>addCovars</code> parameter. Notice how <code>gender</code> is a categorical variable, so when we provide the formula in the <code>addCovars</code> argument, we need to specify that we want to treat it as a factor. If <code>gender</code> is already a factor in the data frame, then the model will still treat it as a factor.</p>

<pre><code class="r">mcp.covars = MCPModGen(&quot;negative binomial&quot;, link = &quot;log&quot;, returnS = F, addCovars = ~ factor(gender),
                    dose = &quot;dose&quot;, resp = &quot;resp&quot;, data = nb.dat, models = models, Delta = 0.6)

mcp.covars
#&gt; MCPMod
#&gt; 
#&gt; Multiple Contrast Test:
#&gt;           t-Stat  adj-p
#&gt; emax      15.509 &lt;0.001
#&gt; quadratic 14.384 &lt;0.001
#&gt; linear    12.122 &lt;0.001
#&gt; 
#&gt; Estimated Dose Response Models:
#&gt; linear model
#&gt;    e0 delta 
#&gt; 0.313 0.004 
#&gt; 
#&gt; emax model
#&gt;     e0   eMax   ed50 
#&gt; -0.082  1.152 14.330 
#&gt; 
#&gt; quadratic model
#&gt;    e0    b1    b2 
#&gt; 0.143 0.015 0.000 
#&gt; 
#&gt; Selected model (AIC): emax
#&gt; 
#&gt; Estimated TD, Delta=0.6
#&gt;    linear      emax quadratic 
#&gt;  139.1470   15.5723   49.2665
plot(mcp.covars)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-16"/></p>

<p>Let&#39;s now see the target dose estimates for our models against the true target dose.</p>

<pre><code class="r">TD(models, Delta = 0.6)[2]
#&gt;     emax 
#&gt; 13.33333

mcp.nb1$MCPMod$doseEst[mcp.nb1$MCPMod$selMod]
#&gt;     emax 
#&gt; 41.37549
mcp.covars$doseEst[mcp.covars$selMod]
#&gt;     emax 
#&gt; 15.57234
</code></pre>

<p>We can clearly see that including the covariates greatly improves the accuracy of the TD estimate.</p>

<h1>Relative Risk</h1>

<p>The relative risk measures either the risk ratio for binomial data or the rate ratio for count data. The main advantage of using the relative risk is that interpretation is incredibly easy and consistent under different data distributions. While the canonical link for negative binomial data is the log-link, it is often difficult to propose candidate models in terms of log-mean. Other links are even more confusing.</p>

<p>For binary data, the relative risk is better known as the risk ratio, where the relative risk for dose \(a\) against the placebo \(p\) is given by
\begin{equation}
  RR<em>a = \frac{\left(\sum</em>{i = 1}<sup>{n_a}</sup> I(outcome)<em>{a,i}\right)/n_a}{\left(\sum</em>{i = 1}<sup>{n_p}</sup> I(outcome)_{p,i}\right)/n_p}
\end{equation}
where \(n_a\) denotes the number of patients who received dose \(a\).</p>

<p>For count data (e.g. negative binomial and Poisson), the relative risk is better known as the rate ratio, where the relative risk for dose \(a\) against the placebo \(p\) is given by
\begin{equation}
  RR<em>a = \frac{\left(\sum</em>{i = 1}<sup>{n_a}</sup> #events<em>{a,i}\right)/\left(\sum</em>{i = 1}<sup>{n_a}</sup> time<em>{a,i} \right)}{\left(\sum</em>{i = 1}<sup>{n_p}</sup> #events<em>{p,i}\right)/\left(\sum</em>{i = 1}<sup>{n_p}</sup> time<em>{p,i} \right)}
\end{equation}
where $#events</em>{a,i}$ denotes the number events that occurred for patient \(i\) of dose \(a\) in the recording time \(time_{a,i}\).</p>

<p>Users can specify candidate models on the relative risk scale and apply the traditional MCP-Mod procedure via the <code>MCPModGeneral</code> package. For power analysis, the user must also supply the mean at the placebo, denoted <code>placEff</code>. An example of data generated from a candidate relative risk dose-response curve and analysis of the data is shown in the following chunk of code.</p>

<pre><code class="r">set.seed(1786)
doses = c(0, 0.1, 0.5, 0.75, 1)
n.vec = c(30, 20, 23, 19, 32)
n.doses = length(doses)
models = Mods(doses = doses, linear = NULL, emax = 0.1, exponential = 0.2,
              quadratic = -0.75, placEff = 1, maxEff = -0.3)

## Perform power-analysis
powMCTGen(n.vec, &quot;binomial&quot;, &quot;risk ratio&quot;, altModels = models, placEff = 0.9,
          Ntype = &quot;actual&quot;)
#&gt; using &#39;placAdj&#39; specification from contMat object
#&gt; using &#39;placAdj&#39; specification from contMat object
#&gt; using &#39;placAdj&#39; specification from contMat object
#&gt; using &#39;placAdj&#39; specification from contMat object
#&gt;      linear        emax exponential   quadratic 
#&gt;   0.8987091   0.9597508   0.8011131   0.9106507




## Simulate the data according to the exponential curve
means = getResp(models)[,3]*0.9
cbind(Dose = doses, Means = means)
#&gt;      Dose     Means
#&gt; 0    0.00 0.9000000
#&gt; 0.1  0.10 0.8988118
#&gt; 0.5  0.50 0.8795183
#&gt; 0.75 0.75 0.8239505
#&gt; 1    1.00 0.6300000

resp.dat = c()
for(i in 1:n.doses){
  resp.dat = c(resp.dat, rbinom(1, size = n.vec[i], prob = means[i]))
}

bin.dat = data.frame(dose = doses, resp = resp.dat/n.vec, w = n.vec)




## Fit using the package

mod.pack = MCPModGen(&quot;binomial&quot;, &quot;risk ratio&quot;, returnS = F, w = &quot;w&quot;, dose = &quot;dose&quot;, resp = &quot;resp&quot;,
                     data = bin.dat, models = models, Delta = 0.1)
#&gt; Forcing &#39;placAdj = TRUE&#39; for risk ratio links

plot(mod.pack)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-18"/></p>

<pre><code class="r">## Look at the MED estimate
mod.pack$doseEst[mod.pack$selMod]
#&gt; exponential 
#&gt;   0.7955145
TD(models, Delta = 0.1, direction = &quot;decreasing&quot;)[3]
#&gt; exponential 
#&gt;   0.7829547
</code></pre>

<h1>Conclusion</h1>

<p>The <code>MCPModGeneral</code> package allows users to use the methods from the <code>DoseFinding</code> package without having to code additional data analysis. While fitting the actual MCP-Mod procedure for non-normal data is often very straightforward, full power-analysis requires extensive coding, which the <code>MCPModGeneral</code> package does for the user. The other significant contribution to the <code>DoseFinding</code> package is the inclusion of the relative risk link. Together, the <code>MCPModGeneral</code> package and <code>DoseFinding</code> package can apply the MCP-Mod procedure to the most common data distributions.</p>

</body>

</html>
